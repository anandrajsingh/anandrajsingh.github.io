1. <b>Performance</b>: Go is a compiled language, which genrally makes it faster than javascript(which is interpreted).

2. <b>Concurrency</b>: Go has built in support for concurrency with goroutines and channels. This makes it easier to write programs that can handle multiple tasks simultaneously, which is particularly useful for network servers and applications with many I/O operations.

3. <b>Static Typing</b>: Go is statically typed, which helps catch error compile time rather than runtime. This can lead to more reliable code and easier refactoring, while Javascript's dynamic typing can lead to some unexpected behaviour.

4. <b>Deployment</b>: Go compiles to a single binary, which simplifies deployment. You don't need to worry about runtime dependencies or versioning issues on the server.

```
package main        //Package declaration
import "fmt"        //Importing from a package
func main() {
	fmt.Println("Hello world")      //Using function from a package.
}
```

**Automatic Formatting**
The Go compiler expects you to format your code correctly, else it won't compile.

**Variable and constants**
Simple data types:
```
package main
import "fmt"

func main(){
    var a int = 45
    var b float64 = 3.14
    var c bool = true
    var d string = "adfgshjls"

    fmt.Println("Integer:", a)
}
```

Shorthand syntax:
```
package main
import "fmt"

func main(){
    a := 42
    b := 5.66
    c := true
    d := "Hello brother"

    fmt.Println("Integer:", a)
}
```

Constants
```
package main
import "fmt"

func main(){
    const a int = 42
    const b float64 = 6.66
    const c bool = true
    const d stirng = "Hellooo gays"

    fmt.Println("Integer:", a)
}
```

**Loops, if-else, switch**
<b>Loops</b>
- Find sum of 0-x

```
package main
import "fmt"

func main(){
    var int x = 10
    sum := 0
    for i := 0; i< x; i++{
        sum += i
    }
    fmt.Println(sum)
}
```

- Range syntax

```
package main
import "fmt"

func main(){
    x := 10
    var int sum = 0
    for i := range x{
        sum += i
    }
    fmt.Println(sum)
}
```

<b>if-else</b>

```
package main
import "fmt"

func main(){
    input := 10
    if input%2 == 0{
        fmt.Println("Input is even.")
    }else {
        fmt.Println("Input is odd.")
    }
}
```

<b>switch</b>

```
package main

func main(){
    var gender string = "male"

    switch gender {
        case "male":
            println("You are male")
        case "female":
            println("You are femaile")
        default :
            println("You are neither male nor female")
    }
}
```


**Arrays, slices and Maps**

<b>Arrays</b>

- <b>Definition</b>: An array is fixed-size, contiguous collection of elements of the same type.
- <b>Characterstics</b>:

1. Size is fixed at the time of declaration and cannot be changed.
2. Arrays are value types. When you assign an array to another array, it copies the entire array.
3. Accessing elements is done via zero-based indexing: arr[0], arr[1] etc

<b>Initialize and empty array</b>

```
package main
import "fmt"

func main(){
    var [5]int
    fmt.Print(a)
}
```
<b>Iterate over an array to find sum of elements inside:</b>

```
package main
import "fmt"

func main(){
    var a [5]int = [5]int{1,2,3,4,5}
    sum := 0
    for i := range a {
        sum += a[i]
    }
    fmt.Println(sum)
}
```

<b>Create a 2-d array</b>

```
package main
import "fmt"

func main(){
    var maze [3][3]int = [3][3]int{
        {1, 2, 3},
		{4, 5, 6},
		{7, 8, 9},
    }
    fmt.Print(maze)
}
```



**Slices**
- <b>Definition</b>: A slice is flexible, dynamically-sized abstraction over an array. Slices provide a way to work with subsets of arrays.
- <b>Syntax</b>: You can create slice from an array or directly using a slice literal
- <b>Characterstics<b>:
1. Slices are reference types, meaning they reference and underlying array. When you pass a slice to a function you are passing a reference, not a copy of data.
2. A slice has three components: a pointer to the array, a length and a capacity
3. You can append elements to a slice using the built-in append function, which may allocate a new underlying if the capacity is exceeded.

<b>Create an empty string slice</b>

```
package main
func main(){
    var users []string
    println(users == nil)
}
```

<b>Create and initialize a string slice</b>

```
package main
import "fmt"
func main() {
	var users []string = []string{"harkirat", "raman"}
	fmt.Print(users)
}

```

<b>Initialize without default value(make)</b>

```
package main
import "fmt"

func main() {
	var users []string = make([]string, 3)
	println(len(users))
	println(cap(users))
	fmt.Print(users[0] == "")
}
```

<b>Copy by reference</b>

```
package main
import "fmt"

func main() {
	var users []string = []string{"harkirat", "raman"}
	var users2 = users // Copied by reference
	users2[0] = "harkirat2"
	fmt.Print(users)
}
```

<b>Copy by value</b>

```
package main
import "fmt"

func main() {
	var users []string = []string{"harkirat", "raman"}
	var users2 = make([]string, len(users))

	copy(users2, users)
	users2[0] = "harkirat2"
	fmt.Print(users)
}

```

**Maps**
Maps in go are built-in data types that associate keys with values, similar to dictionaries and hash tables in other programming languages. They are unordered collections that allow you to store and retrieve data efficiently.

<b>Create a map</b>

```
m := make(map[string]int) // Creates a map with string keys and int values
```

<b>Create and initialize a map</b>

```
m := map[string]int{
    "Alice": 25,
    "Bob":   30,
}
```

<b>Delete a key</b>
```
delete(m, "Alice")
```

<b>Check if a key exists</b>

```
package main
import "fmt"

func main() {
	m := map[string]int{
		"Raman": 1,
		"kirat": 2,
	}

	delete(m, "Raman")
	value, exists := m["Raman"]

	if exists {
		fmt.Print("Value found ", value)
	} else {
		fmt.Print("Value not found")
	}
}
```





**Functions**
Functions in Go are first-class citizens, meaning they can be assigned to variables, passed as arguments, and returned from other functions.

<b>Sum function</b>

```
package main
import "fmt"

func sum(a int, b int) int {
	return a + b
}

func main() {
	fmt.Println(sum(2, 3))
}
```

**Variants**
<b>Parameters</b>: You can define multiple parameters of the same type in a single declaration:

```
func add(a,b int) int{
    return a + b
}
```

<b>Return Types</b>: You can return multiple values from a function:

```
package main
import "fmt"

func calculator(a,b int) (int, int){
    return a+b, a-b
}

func main(){
    sum, sub := calculator(3,2)
    fmt.Println(sum, " ", sub)
}
```

**Named Return Values**
You can also define named return values in a function. This allows you to specify the return values in the funciton signature, making the code easier to read and understand:

```
package main
import "fmt"

func calculator(a,b int) (sum int, sub int){
    sum = a + b
    sub = a - b
    return
}

func main(){
    sum, sub := calculator(2,3)
    fmt.Println(sum, " ", sub)
}
```

**Anonymous Functions**

```
package main
import "fmt"

func main(){
    sum, sub := func(a, b int)(sum int, sub int){
        sum = a + b
        sub = a - b
        return
    }(3,2)
}
```

**Functions as arguments**

```
package main
import "fmt"

func sum(a int, b int) int {
    return a + b
}

func sub(a int, b int) int {
    return a - b
}

func calculator(a int, b int, fn func(int, int) int) int{
    return fn(a,b)
}

func main(){
    ans := calculator(3,2, sum)
    fmt.Println(ans)
}
```

**Returning Functions**

```
package main
import "fmt"

func multiplier(factor int) func(int) int {
	return func(a int) int {
		return a * factor
	}
}

func main() {
	double := multiplier(2)
	tripple := multiplier(3)

	fmt.Println(double(3))
	fmt.Println(tripple(3))
}
```



**Structs, attaching methods**
In Go, a struct is a composite data type that groups togethor variables (fields) under a single name. Each field can have a different type, making struct a powerful way to represent complex data structure.

```
///Define a struct
type rect struct{
    width int32
    height int 32
}

//Creating a new instance of rect struct
r := rect{width:200, height: 200}

//Writing a function to calculate the area of rect
func area(r rect) int32{
    return r.height * r.width
}

//Print the area
fmt.Println(area(r))
```

**Struct methods**
You can define methods on structs, allowing you to associate behaviour with your data types. To define a method for a struct, you specify a receiver (which can be a <b>value</b> or a <b>pointer</b>) in the method definition:

- <b>Value receiver</b>

```
type rect struct {
	width  int32
	height int32
}

func (r rect) area() int {
   return r.width * r.height
}
```

- <b>Pointer receiver</b>

```
type rect struct{
    width int32
    height int32
}

func (r *rect) area() int32{
    return r.width * r.height
}
```

<b>If you mutate the value of struct in a pointer receiver, it is propagated to the final variable (both are referencing the same place in the memory)</b>