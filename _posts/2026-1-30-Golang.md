1. <b>Performance</b>: Go is a compiled language, which genrally makes it faster than javascript(which is interpreted).

2. <b>Concurrency</b>: Go has built in support for concurrency with goroutines and channels. This makes it easier to write programs that can handle multiple tasks simultaneously, which is particularly useful for network servers and applications with many I/O operations.

3. <b>Static Typing</b>: Go is statically typed, which helps catch error compile time rather than runtime. This can lead to more reliable code and easier refactoring, while Javascript's dynamic typing can lead to some unexpected behaviour.

4. <b>Deployment</b>: Go compiles to a single binary, which simplifies deployment. You don't need to worry about runtime dependencies or versioning issues on the server.

```
package main        //Package declaration
import "fmt"        //Importing from a package
func main() {
	fmt.Println("Hello world")      //Using function from a package.
}
```

**Automatic Formatting**
The Go compiler expects you to format your code correctly, else it won't compile.

**Variable and constants**
Simple data types:
```
package main
import "fmt"

func main(){
    var a int = 45
    var b float64 = 3.14
    var c bool = true
    var d string = "adfgshjls"

    fmt.Println("Integer:", a)
}
```

Shorthand syntax:
```
package main
import "fmt"

func main(){
    a := 42
    b := 5.66
    c := true
    d := "Hello brother"

    fmt.Println("Integer:", a)
}
```

Constants
```
package main
import "fmt"

func main(){
    const a int = 42
    const b float64 = 6.66
    const c bool = true
    const d stirng = "Hellooo gays"

    fmt.Println("Integer:", a)
}
```

**Loops, if-else, switch**
<b>Loops</b>
- Find sum of 0-x

```
package main
import "fmt"

func main(){
    var int x = 10
    sum := 0
    for i := 0; i< x; i++{
        sum += i
    }
    fmt.Println(sum)
}
```

- Range syntax

```
package main
import "fmt"

func main(){
    x := 10
    var int sum = 0
    for i := range x{
        sum += i
    }
    fmt.Println(sum)
}
```

<b>if-else</b>

```
package main
import "fmt"

func main(){
    input := 10
    if input%2 == 0{
        fmt.Println("Input is even.")
    }else {
        fmt.Println("Input is odd.")
    }
}
```

<b>switch</b>

```
package main

func main(){
    var gender string = "male"

    switch gender {
        case "male":
            println("You are male")
        case "female":
            println("You are femaile")
        default :
            println("You are neither male nor female")
    }
}
```


**Arrays, slices and Maps**

<b>Arrays</b>

- <b>Definition</b>: An array is fixed-size, contiguous collection of elements of the same type.
- <b>Characterstics</b>:

1. Size is fixed at the time of declaration and cannot be changed.
2. Arrays are value types. When you assign an array to another array, it copies the entire array.
3. Accessing elements is done via zero-based indexing: arr[0], arr[1] etc

<b>Initialize and empty array</b>

```
package main
import "fmt"

func main(){
    var [5]int
    fmt.Print(a)
}
```
<b>Iterate over an array to find sum of elements inside:</b>

```
package main
import "fmt"

func main(){
    var a [5]int = [5]int{1,2,3,4,5}
    sum := 0
    for i := range a {
        sum += a[i]
    }
    fmt.Println(sum)
}
```

<b>Create a 2-d array</b>

```
package main
import "fmt"

func main(){
    var maze [3][3]int = [3][3]int{
        {1, 2, 3},
		{4, 5, 6},
		{7, 8, 9},
    }
    fmt.Print(maze)
}
```



**Slices**
- <b>Definition</b>: A slice is flexible, dynamically-sized abstraction over an array. Slices provide a way to work with subsets of arrays.
- <b>Syntax</b>: You can create slice from an array or directly using a slice literal
- <b>Characterstics<b>:
1. Slices are reference types, meaning they reference and underlying array. When you pass a slice to a function you are passing a reference, not a copy of data.
2. A slice has three components: a pointer to the array, a length and a capacity
3. You can append elements to a slice using the built-in append function, which may allocate a new underlying if the capacity is exceeded.

<b>Create an empty string slice</b>

```
package main
func main(){
    var users []string
    println(users == nil)
}
```

<b>Create and initialize a string slice</b>

```
package main
import "fmt"
func main() {
	var users []string = []string{"harkirat", "raman"}
	fmt.Print(users)
}

```

<b>Initialize without default value(make)</b>

```
package main
import "fmt"

func main() {
	var users []string = make([]string, 3)
	println(len(users))
	println(cap(users))
	fmt.Print(users[0] == "")
}
```

<b>Copy by reference</b>

```
package main
import "fmt"

func main() {
	var users []string = []string{"harkirat", "raman"}
	var users2 = users // Copied by reference
	users2[0] = "harkirat2"
	fmt.Print(users)
}
```

<b>Copy by value</b>

```
package main
import "fmt"

func main() {
	var users []string = []string{"harkirat", "raman"}
	var users2 = make([]string, len(users))

	copy(users2, users)
	users2[0] = "harkirat2"
	fmt.Print(users)
}

```

**Maps**
Maps in go are built-in data types that associate keys with values, similar to dictionaries and hash tables in other programming languages. They are unordered collections that allow you to store and retrieve data efficiently.

<b>Create a map</b>

```
m := make(map[string]int) // Creates a map with string keys and int values
```

<b>Create and initialize a map</b>

```
m := map[string]int{
    "Alice": 25,
    "Bob":   30,
}
```

<b>Delete a key</b>
```
delete(m, "Alice")
```

<b>Check if a key exists</b>

```
package main
import "fmt"

func main() {
	m := map[string]int{
		"Raman": 1,
		"kirat": 2,
	}

	delete(m, "Raman")
	value, exists := m["Raman"]

	if exists {
		fmt.Print("Value found ", value)
	} else {
		fmt.Print("Value not found")
	}
}
```